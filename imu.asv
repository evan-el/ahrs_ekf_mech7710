clear all
close all
clc

% columns 1-3 accel [m/s^2]
% 4-6 gyro [rad/s]
% 7-9 mag [uT]
[data, dt] = loadSoftsysData("hw3_data.txt");

% dt = 0.01;
% data = simImuData(dt);

accel = data(:, 1:3);
gyro = data(:, 4:6);
mag = data(:, 7:9);

% initial rotation matrix, normalize columns
C_init = [cross(cross(accel(1,:)', mag(1,:)'), accel(1,:)') cross(accel(1,:)',mag(1,:)') accel(1,:)'];
C_init(:, 1) = C_init(:,1)./norm(C_init(:,1));
C_init(:, 2) = C_init(:,2)./norm(C_init(:,2));
C_init(:, 3) = C_init(:,3)./norm(C_init(:,3));

q_hat(:, 1) = [(1/2)*sqrt(C_init(1,1)+C_init(2,2)+C_init(3,3)+1);
               (1/2)*sign(C_init(3,2)-C_init(2,3))*sqrt(C_init(1,1)-C_init(2,2)-C_init(3,3)+1);
               (1/2)*sign(C_init(1,3)-C_init(3,1))*sqrt(C_init(2,2)-C_init(3,3)-C_init(1,1)+1);
               (1/2)*sign(C_init(2,1)-C_init(1,2))*sqrt(C_init(3,3)-C_init(1,1)-C_init(2,2)+1)];
q_hat_gyro_only(:, 1) = q_hat(:,1);
eul_gyro_only(:, 1) = [0; 0; 0];
eul(:, 1) = [0; 0; 0];
t(1) = 0;

P = eye(4);
sigma_gyro = 0.3; % assuming equal noise on each axis
Sigma_gyro = (sigma_gyro^2).*eye(3);

% assuming equal noise on each axis
sigma_acc = 0.5; 
sigma_mag = 0.8;
R = [(sigma_acc^2).*eye(3) zeros(3);
     zeros(3) (sigma_mag^2).*eye(3)];

magnetic_dip_angle = deg2rad(-14.78); % deg, for auburn, al, from magnetic-declination.com
magnetic_field_vec = [cos(magnetic_dip_angle) 0 sin(magnetic_dip_angle)]'./sqrt(cos(magnetic_dip_angle)^2 + sin(magnetic_dip_angle)^2); % ned
grav_vec = [0 0 -1]'; % ned

% magnetic_field_vec = [0 cos(magnetic_dip_angle) -sin(magnetic_dip_angle)]'./sqrt(cos(magnetic_dip_angle)^2 + sin(magnetic_dip_angle)^2); % enu
% grav_vec = [0 0 1]'; % enu

for i = 1:length(accel(:, 1))
    t(i+1) = dt*i;

    % --- time update----
    Omega = [0            -gyro(i,1) -gyro(i,2) -gyro(i,3);
             gyro(i,1)    0           gyro(i,3) -gyro(i,2);
             gyro(i,2)    -gyro(i,3)  0          gyro(i,1);
             gyro(i,3)     gyro(i,2)  -gyro(i,1) 0];
    state_prop = cos(norm(gyro(i, :))*dt/2)*eye(4) + (2/(norm(gyro(i,:))))...
                    *sin(norm(gyro(i,:))*dt/2)*Omega;
    q_hat(:, i+1) = state_prop*q_hat(:,i);
    q_hat_gyro_only(:, i+1) = state_prop*q_hat_gyro_only(:, i);
    eul_gyro_only(:, i+1) = rad2deg(quat2eul(q_hat_gyro_only(:, i+1)', "XYZ"));

    A_d = [1 (-dt/2)*gyro(i,1) (-dt/2)*gyro(i,2) (-dt/2)*gyro(i,3);
           (dt/2)*gyro(i,1) 1 (dt/2)*gyro(i,3) (-dt/2)*gyro(i,2);
           (dt/2)*gyro(i,2) (-dt/2)*gyro(i,3) 1 (dt/2)*gyro(i,1);
           (dt/2)*gyro(i,3) (dt/2)*gyro(i,2) (-dt/2)*gyro(i,1) 1];

    % Jacobian of f w.r.t. angular rates (omega)
    W = (dt/2).*[-q_hat(2, i+1)  -q_hat(3, i+1)  -q_hat(4, i+1);
                  q_hat(1, i+1)  -q_hat(4, i+1)   q_hat(3, i+1);
                  q_hat(4, i+1)   q_hat(1, i+1)  -q_hat(2, i+1);
                 -q_hat(3, i+1)   q_hat(2, i+1)  -q_hat(1, i+1)];

    Q = W*Sigma_gyro*W'; % Q changes over time depending on angular vel
    
    % covariance propagation
    P = A_d*P*A_d' + Q;

    % --- measurement correction ---

    % normalize the accel and mag so we can compare them with our gravity
    % and magnetic field unit vectors
    accel_normalized = accel(i,:)./(norm(accel(i,:)));
    mag_normalized = mag(i,:)./(norm(mag(i,:)));

    % rotate gravity and mag vectors into sensor's frame (this is the
    % nonlinear measurement model, h(x))
    rot_mat = quatToRotMat(q_hat(:, i+1));
    accel_hat = rot_mat'*grav_vec;
    mag_hat = rot_mat'*magnetic_field_vec;
    Y_hat = [accel_hat; mag_hat];

    % form jacobian of measurement model (H)
    u_g = cross(grav_vec, q_hat(2:4, i+1));
    u_r = cross(magnetic_field_vec, q_hat(2:4, i+1));
    skew_sym_first_row = vec3ToSkewSym(u_g+q_hat(1,i+1)*grav_vec);
    skew_sym_second_row = vec3ToSkewSym(u_r+q_hat(1,i+1)*magnetic_field_vec);
    H = 2.*[u_g skew_sym_first_row+dot(q_hat(2:4,i+1),grav_vec)*eye(3)-grav_vec*q_hat(2:4,i+1)';
            u_r skew_sym_second_row+dot(q_hat(2:4,i+1),magnetic_field_vec)-magnetic_field_vec*q_hat(2:4,i+1)'];

    Y = [accel(i, :)'; mag(i, :)'];

    % compute Kalman gain
    v = Y - Y_hat;
    S = H*P*H' + R;
    K = P*H'*inv(S);

    % apply measurement correction to state and covariance
    q_hat(:, i+1) = q_hat(:, i+1) + K*v;
    P = (eye(4) - K*H)*P';

    % normalize quaternion
    q_hat(:, i+1) = q_hat(:, i+1)/norm(q_hat(:, i+1));

    eul(:, i+1) = rad2deg(quat2eul(q_hat(:, i+1)', "XYZ"));
end


figure
plot(t, eul(1, :));
hold on
plot(t, eul_gyro_only(1,:));
legend("EKF", "Gyro Only");
title("X axis");

figure
plot(t, eul(2, :));
hold on
plot(t, eul_gyro_only(1,:));
legend("EKF", "Gyro Only");
title("Y axis");

figure
plot(t, eul(3, :));
hold on
plot(t, eul_gyro_only(1,:));
legend("EKF", "Gyro Only");
title("Z axis");
